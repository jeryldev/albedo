defmodule Albedo.Output.FeatureDoc do
  @moduledoc """
  Generates the final FEATURE.md document from session data.
  """

  alias Albedo.Output.Markdown

  @doc """
  Generate a complete FEATURE.md document from session state.
  """
  def generate(session_state) do
    sections = [
      generate_header(session_state),
      generate_executive_summary(session_state),
      generate_domain_context(session_state),
      generate_scope(session_state),
      Markdown.horizontal_rule(),
      generate_technical_overview(session_state),
      Markdown.horizontal_rule(),
      generate_tickets(session_state),
      Markdown.horizontal_rule(),
      generate_dependency_graph(session_state),
      generate_implementation_order(session_state),
      generate_risk_summary(session_state),
      generate_effort_estimate(session_state),
      Markdown.horizontal_rule(),
      generate_appendix(session_state)
    ]

    Markdown.join_sections(sections)
  end

  defp generate_header(state) do
    """
    # Feature: #{state.task}

    **Generated by:** Albedo v0.1.0
    **Date:** #{Date.utc_today()}
    **Session:** #{state.session_dir}
    """
  end

  defp generate_executive_summary(state) do
    summary = state.summary || %{}

    """
    ## Executive Summary

    This document contains the implementation plan for the requested feature.

    - **Tickets:** #{summary[:tickets_count] || "N/A"}
    - **Estimated Points:** #{summary[:total_points] || "N/A"}
    - **Files to Create:** #{summary[:files_to_create] || "N/A"}
    - **Files to Modify:** #{summary[:files_to_modify] || "N/A"}
    - **Risks Identified:** #{summary[:risks_identified] || "N/A"}
    """
  end

  defp generate_domain_context(state) do
    domain = get_in(state.context, [:domain_research, :content])

    if domain do
      """
      ## Domain Context

      Key domain knowledge that informed this plan:

      #{extract_key_points(domain, 5)}
      """
    else
      ""
    end
  end

  defp generate_scope(_state) do
    """
    ## Scope

    ### In Scope
    - Implementation as specified in the task description
    - Related test coverage
    - Documentation updates

    ### Out of Scope
    - Performance optimization (unless critical)
    - Unrelated refactoring

    ### Assumptions
    - Existing infrastructure is stable
    - Team has access to required dependencies
    """
  end

  defp generate_technical_overview(state) do
    tech = get_in(state.context, [:tech_stack, :content])
    arch = get_in(state.context, [:architecture, :content])

    """
    ## Technical Overview

    ### Technology Stack
    #{summarize_section(tech, 300)}

    ### Architecture
    #{summarize_section(arch, 300)}
    """
  end

  defp generate_tickets(state) do
    planning = get_in(state.context, [:change_planning, :content])

    if planning do
      """
      ## Tickets

      #{extract_tickets_section(planning)}
      """
    else
      """
      ## Tickets

      No tickets generated. Check the change planning phase output.
      """
    end
  end

  defp generate_dependency_graph(_state) do
    """
    ## Dependency Graph

    ```mermaid
    graph LR
        T1[Ticket 1] --> T2[Ticket 2]
        T2 --> T3[Ticket 3]
    ```

    *Note: See individual tickets for detailed dependencies.*
    """
  end

  defp generate_implementation_order(_state) do
    """
    ## Implementation Order

    1. Start with tickets that have no dependencies
    2. Progress through dependent tickets in order
    3. Run tests after each ticket
    4. Final integration testing
    """
  end

  defp generate_risk_summary(_state) do
    """
    ## Risk Summary

    | Risk | Likelihood | Impact | Mitigation |
    |------|------------|--------|------------|
    | Breaking changes | Medium | High | Thorough testing |
    | Integration issues | Low | Medium | Incremental deployment |
    """
  end

  defp generate_effort_estimate(state) do
    summary = state.summary || %{}

    """
    ## Estimated Total Effort

    | Category | Tickets | Points |
    |----------|---------|--------|
    | Total | #{summary[:tickets_count] || "?"} | #{summary[:total_points] || "?"} |
    """
  end

  defp generate_appendix(state) do
    """
    ## Appendix

    ### Research Files
    All research that informed this plan:

    - [00_domain_research.md](./00_domain_research.md)
    - [01_tech_stack.md](./01_tech_stack.md)
    - [02_architecture.md](./02_architecture.md)
    - [03_conventions.md](./03_conventions.md)
    - [04_feature_location.md](./04_feature_location.md)
    - [05_impact_analysis.md](./05_impact_analysis.md)

    ### Clarifying Questions Asked
    #{format_questions(state.clarifying_questions)}
    """
  end

  defp extract_key_points(content, count) when is_binary(content) do
    content
    |> String.split("\n")
    |> Enum.filter(&String.starts_with?(&1, "- "))
    |> Enum.take(count)
    |> Enum.join("\n")
  end

  defp extract_key_points(_, _), do: "No domain research available."

  defp summarize_section(nil, _), do: "Not available."

  defp summarize_section(content, max_length) when is_binary(content) do
    if String.length(content) > max_length do
      String.slice(content, 0, max_length) <> "..."
    else
      content
    end
  end

  defp extract_tickets_section(content) when is_binary(content) do
    case Regex.run(~r/(### Ticket #1.*)/s, content) do
      [_, tickets] -> tickets
      _ -> content
    end
  end

  defp extract_tickets_section(_), do: "No tickets available."

  defp format_questions([]), do: "No clarifying questions were asked."

  defp format_questions(questions) do
    questions
    |> Enum.with_index(1)
    |> Enum.map_join("\n", fn {q, idx} ->
      "#{idx}. #{q[:question]} â†’ #{q[:answer] || "Pending"}"
    end)
  end
end
