defmodule Albedo.Tickets.Exporters.GitHub do
  @moduledoc """
  Exports tickets to GitHub Issues format.
  Produces JSON compatible with GitHub's issue import API.
  Each ticket becomes an issue with labels for type, priority, and estimate.
  """

  @behaviour Albedo.Tickets.Exporter

  alias Albedo.Tickets.Exporter

  @impl true
  def export(tickets_data, opts \\ []) do
    tickets = Exporter.filter_by_status(tickets_data.tickets, opts)

    issues = Enum.map(tickets, &ticket_to_issue/1)

    output = %{
      "source" => "albedo",
      "session_id" => tickets_data.session_id,
      "exported_at" => DateTime.utc_now() |> DateTime.to_iso8601(),
      "issues" => issues
    }

    case Jason.encode(output, pretty: true) do
      {:ok, json} -> {:ok, json}
      {:error, reason} -> {:error, {:json_encode, reason}}
    end
  end

  @impl true
  def file_extension, do: ".github.json"

  @impl true
  def format_name, do: "GitHub Issues"

  defp ticket_to_issue(ticket) do
    %{
      "title" => ticket.title,
      "body" => format_body(ticket),
      "labels" => build_labels(ticket),
      "state" => if(ticket.status == :completed, do: "closed", else: "open")
    }
  end

  defp format_body(ticket) do
    []
    |> add_description(ticket)
    |> add_implementation_notes(ticket)
    |> add_files_to_create(ticket)
    |> add_files_to_modify(ticket)
    |> add_acceptance_criteria(ticket)
    |> add_dependencies(ticket)
    |> add_footer()
    |> Enum.join("\n")
    |> String.trim()
  end

  defp add_description(sections, %{description: nil}), do: sections
  defp add_description(sections, %{description: desc}), do: sections ++ [desc, ""]

  defp add_implementation_notes(sections, %{implementation_notes: nil}), do: sections

  defp add_implementation_notes(sections, %{implementation_notes: notes}) do
    sections ++ ["## Implementation Notes", "", notes, ""]
  end

  defp add_files_to_create(sections, %{files: %{create: []}}), do: sections

  defp add_files_to_create(sections, %{files: %{create: files}}) do
    content = Enum.map_join(files, "\n", &"- `#{&1}`")
    sections ++ ["## Files to Create", "", content, ""]
  end

  defp add_files_to_modify(sections, %{files: %{modify: []}}), do: sections

  defp add_files_to_modify(sections, %{files: %{modify: files}}) do
    content = Enum.map_join(files, "\n", &"- `#{&1}`")
    sections ++ ["## Files to Modify", "", content, ""]
  end

  defp add_acceptance_criteria(sections, %{acceptance_criteria: []}), do: sections

  defp add_acceptance_criteria(sections, %{acceptance_criteria: criteria}) do
    content =
      criteria
      |> Enum.map(&String.replace(&1, ~r/^\s*\[[ x~]\]\s*/, ""))
      |> Enum.map_join("\n", &"- [ ] #{&1}")

    sections ++ ["## Acceptance Criteria", "", content, ""]
  end

  defp add_dependencies(sections, %{dependencies: %{blocked_by: [], blocks: []}}), do: sections

  defp add_dependencies(sections, %{dependencies: deps}) do
    dep_lines =
      []
      |> maybe_add_blocked_by(deps.blocked_by)
      |> maybe_add_blocks(deps.blocks)

    if dep_lines == [],
      do: sections,
      else: sections ++ ["## Dependencies", ""] ++ dep_lines ++ [""]
  end

  defp maybe_add_blocked_by(lines, []), do: lines

  defp maybe_add_blocked_by(lines, blocked_by) do
    blocked = Enum.map_join(blocked_by, ", ", &"##{&1}")
    lines ++ ["**Blocked by:** #{blocked}"]
  end

  defp maybe_add_blocks(lines, []), do: lines

  defp maybe_add_blocks(lines, blocks) do
    blocks_str = Enum.map_join(blocks, ", ", &"##{&1}")
    lines ++ ["**Blocks:** #{blocks_str}"]
  end

  defp add_footer(sections),
    do: sections ++ ["---", "", "_Generated by [Albedo](https://github.com/albedo-cli)_"]

  defp build_labels(ticket) do
    labels = ticket.labels

    labels = ["type:#{ticket.type}" | labels]
    labels = ["priority:#{ticket.priority}" | labels]

    labels =
      if ticket.estimate do
        ["estimate:#{ticket.estimate}" | labels]
      else
        labels
      end

    Enum.reverse(labels)
  end
end
