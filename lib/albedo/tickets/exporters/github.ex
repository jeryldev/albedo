defmodule Albedo.Tickets.Exporters.GitHub do
  @moduledoc """
  Exports tickets to GitHub Issues format.
  Produces JSON compatible with GitHub's issue import API.
  Each ticket becomes an issue with labels for type, priority, and estimate.
  """

  @behaviour Albedo.Tickets.Exporter

  alias Albedo.Tickets.Exporter

  @impl true
  def export(tickets_data, opts \\ []) do
    tickets = Exporter.filter_by_status(tickets_data.tickets, opts)

    issues = Enum.map(tickets, &ticket_to_issue/1)

    output = %{
      "source" => "albedo",
      "session_id" => tickets_data.session_id,
      "exported_at" => DateTime.utc_now() |> DateTime.to_iso8601(),
      "issues" => issues
    }

    case Jason.encode(output, pretty: true) do
      {:ok, json} -> {:ok, json}
      {:error, reason} -> {:error, {:json_encode, reason}}
    end
  end

  @impl true
  def file_extension, do: ".github.json"

  @impl true
  def format_name, do: "GitHub Issues"

  defp ticket_to_issue(ticket) do
    %{
      "title" => ticket.title,
      "body" => format_body(ticket),
      "labels" => build_labels(ticket),
      "state" => if(ticket.status == :completed, do: "closed", else: "open")
    }
  end

  defp format_body(ticket) do
    sections = []

    sections =
      if ticket.description do
        sections ++ [ticket.description, ""]
      else
        sections
      end

    sections =
      if ticket.implementation_notes do
        sections ++ ["## Implementation Notes", "", ticket.implementation_notes, ""]
      else
        sections
      end

    sections =
      if ticket.files.create != [] do
        files = Enum.map_join(ticket.files.create, "\n", &"- `#{&1}`")
        sections ++ ["## Files to Create", "", files, ""]
      else
        sections
      end

    sections =
      if ticket.files.modify != [] do
        files = Enum.map_join(ticket.files.modify, "\n", &"- `#{&1}`")
        sections ++ ["## Files to Modify", "", files, ""]
      else
        sections
      end

    sections =
      if ticket.acceptance_criteria != [] do
        criteria =
          ticket.acceptance_criteria
          |> Enum.map(&String.replace(&1, ~r/^\s*\[[ x~]\]\s*/, ""))
          |> Enum.map_join("\n", &"- [ ] #{&1}")

        sections ++ ["## Acceptance Criteria", "", criteria, ""]
      else
        sections
      end

    sections =
      if ticket.dependencies.blocked_by != [] || ticket.dependencies.blocks != [] do
        deps = []

        deps =
          if ticket.dependencies.blocked_by != [] do
            blocked = Enum.map_join(ticket.dependencies.blocked_by, ", ", &"##{&1}")
            deps ++ ["**Blocked by:** #{blocked}"]
          else
            deps
          end

        deps =
          if ticket.dependencies.blocks != [] do
            blocks = Enum.map_join(ticket.dependencies.blocks, ", ", &"##{&1}")
            deps ++ ["**Blocks:** #{blocks}"]
          else
            deps
          end

        sections ++ ["## Dependencies", ""] ++ deps ++ [""]
      else
        sections
      end

    sections = sections ++ ["---", "", "_Generated by [Albedo](https://github.com/albedo-cli)_"]

    Enum.join(sections, "\n") |> String.trim()
  end

  defp build_labels(ticket) do
    labels = ticket.labels

    labels = ["type:#{ticket.type}" | labels]
    labels = ["priority:#{ticket.priority}" | labels]

    labels =
      if ticket.estimate do
        ["estimate:#{ticket.estimate}" | labels]
      else
        labels
      end

    Enum.reverse(labels)
  end
end
