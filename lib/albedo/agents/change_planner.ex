defmodule Albedo.Agents.ChangePlanner do
  @moduledoc """
  Phase 4: Change Planning Agent.
  Generates concrete, actionable tickets based on all previous research.
  """

  use Albedo.Agents.Base

  alias Albedo.LLM.Prompts

  @impl Albedo.Agents.Base
  def investigate(state) do
    task = state.task
    context = state.context
    greenfield? = get_in(state.config, [:greenfield]) || false

    prompt = Prompts.change_planning(task, context)

    case call_llm(prompt, max_tokens: 16_384) do
      {:ok, response} ->
        summary = extract_summary(response)

        findings = %{
          content: response,
          tickets_count: summary.tickets_count,
          total_points: summary.total_points,
          files_to_create: summary.files_to_create,
          files_to_modify: summary.files_to_modify,
          risks_identified: summary.risks_identified,
          greenfield: greenfield?
        }

        {:ok, findings}

      {:error, reason} ->
        {:error, reason}
    end
  end

  @impl Albedo.Agents.Base
  def format_output(findings) do
    add_metadata_header(findings.content, findings[:greenfield] || false)
  end

  defp add_metadata_header(content, greenfield?) do
    """
    <!-- Generated by Albedo v#{Albedo.version()} on #{Date.utc_today()} -->

    #{content}

    ---

    ## Appendix

    ### Research Files
    All research that informed this plan:

    #{research_files_list(greenfield?)}
    """
  end

  defp research_files_list(true) do
    # Greenfield projects skip conventions, feature_location, and impact_analysis
    """
    - [00_domain_research.md](./00_domain_research.md)
    - [01_tech_stack.md](./01_tech_stack.md)
    - [02_architecture.md](./02_architecture.md)
    """
  end

  defp research_files_list(false) do
    """
    - [00_domain_research.md](./00_domain_research.md)
    - [01_tech_stack.md](./01_tech_stack.md)
    - [02_architecture.md](./02_architecture.md)
    - [03_conventions.md](./03_conventions.md)
    - [04_feature_location.md](./04_feature_location.md)
    - [05_impact_analysis.md](./05_impact_analysis.md)
    """
  end

  defp extract_summary(content) do
    tickets_count = count_tickets(content)
    total_points = extract_total_points(content)
    files_to_create = count_files_to_create(content)
    files_to_modify = count_files_to_modify(content)
    risks_identified = count_risks(content)

    %{
      tickets_count: tickets_count,
      total_points: total_points,
      files_to_create: files_to_create,
      files_to_modify: files_to_modify,
      risks_identified: risks_identified
    }
  end

  defp count_tickets(content) do
    Regex.scan(~r/### Ticket #\d+/, content)
    |> length()
  end

  defp extract_total_points(content) do
    case Regex.run(~r/\*\*Total\*\*.*?(\d+)/, content) do
      [_, points] -> String.to_integer(points)
      _ -> estimate_points(content)
    end
  end

  defp estimate_points(content) do
    small = length(Regex.scan(~r/Estimate.*Small/i, content)) * 2
    medium = length(Regex.scan(~r/Estimate.*Medium/i, content)) * 5
    large = length(Regex.scan(~r/Estimate.*Large/i, content)) * 8
    small + medium + large
  end

  defp count_files_to_create(content) do
    sections = Regex.scan(~r/#### Files to Create\n\|.*?\n\|.*?\n((?:\|.*?\n)*)/s, content)

    sections
    |> Enum.flat_map(fn [_, table] ->
      String.split(table, "\n", trim: true)
    end)
    |> Enum.filter(&String.starts_with?(&1, "|"))
    |> length()
  end

  defp count_files_to_modify(content) do
    sections = Regex.scan(~r/#### Files to Modify\n\|.*?\n\|.*?\n((?:\|.*?\n)*)/s, content)

    sections
    |> Enum.flat_map(fn [_, table] ->
      String.split(table, "\n", trim: true)
    end)
    |> Enum.filter(&String.starts_with?(&1, "|"))
    |> length()
  end

  defp count_risks(content) do
    risk_section =
      Regex.run(~r/## Risk Summary\n\n\|.*?\n\|.*?\n((?:\|.*?\n)*)/s, content)

    case risk_section do
      [_, table] ->
        table
        |> String.split("\n", trim: true)
        |> Enum.filter(&String.starts_with?(&1, "|"))
        |> length()

      _ ->
        length(Regex.scan(~r/\| High \||\| Medium \|/i, content))
    end
  end
end
